# Image synthesis in rendertoy

OpenCL manages images and efficient sampling on GPU. Normally, an image is a multidimensional array
of values (texels). Some extensions can be used to support writing and reading from mipmap images.
Nevertheless, in `rendertoy` we will use images only to write render targets. There is a strong 
limitation with the images in OpenCL that prevents from passing image objects to non-kernel functions,
work with pointers to the content, among others.

For general-purpose textures (that should be accessible from different parts of the code) we propose
a workaround using a common memory pool (char*) accessible globally, and a descriptor of where
an image is located inside the heap. But, this discussion will be detailed in next sections.

Now, we will concentrate in the use of images as arguments of the main kernel function.

## Image creation

OpenCL image objects are created in `rendertoy` via the function
`create_image2d(width, height, type)`. For instance, next example creates an image
of 6 pixels width, 4 pixels height and type `ImageFormat(channel_order.RGBA, channel_type.FLOAT)`.
Some predefined mapped types exist in the project that can be extended in a future.

```python
im = ren.create_image2d(6, 4, ren.float4)
```

The current maps are:

```python
{
    float4: ImageFormat(channel_order.RGBA, channel_type.FLOAT),
    float3: ImageFormat(channel_order.RGB, channel_type.FLOAT),
    float2: ImageFormat(channel_order.RG, channel_type.FLOAT),
    np.float32: ImageFormat(channel_order.R, channel_type.FLOAT),
    RGBA: ImageFormat(channel_order.BGRA, channel_type.UNORM_INT8)
}
```

Important cases are those related with a 4 component image, like RGBA of floats or BGRA of bytes.
Last case is the format commonly used in images by operative systems: a 32bit integer
with one byte by component (e.g., `0xFFFFFFFF` is white, `0xFFFF0000` red, `0xFF00FF00` green and
`0xFF0000FF` the blue).

## Updating pixels

The images can be mapped to the CPU to update the content, or access to a content 
generated on the GPU. When mapping an image a numpy array with shape (height, width, components)
is returned, and the type used depends on what kind of channel_type is used 
(e.g. `float` or `uint8`).

Next code maps an image and update the red component (0-th component) to one.

```python
with ren.mapped(im) as map:
    map[:, :, 0] = 1.0
```

An important observation here is that in arrays the rows are the dimension 0 and columns are
dimension 1. That means that an image mapped as numpy array will have shape (height, width, ...)
instead of (width, height, ...), e.g. `map[1,4]` is the pixel `(4,1)` of the image.

## Using images in kernels

Pixels of the image can be generated by a kernel. In this case different "types" are used
to represent whenever the image will be writable or readonly. OpenCL 1.1 doesn't support
read/write images, but in our case is not mandatory. Read/write images can be managed within
the global memory pool if necessary. Efficient hardware image access is only necessary to  
render pixels to the final render-target or to implement fast and efficient image operations.
In those cases, we use read-only images as sources and write-only images as destination.

```python
@ren.kernel_main
def clear_image(
    im: ren.w_image2d_t,
):
    """
    int2 dim = get_image_dim(im);
    // in rendering, only linear layout of threads is allowed. Mapping to image positions needs to be done manually.
    int px = thread_id % dim.x;
    int py = thread_id / dim.x;
    write_imagef(im, (int2)(px,py), (float4)(1.0, 0.5, 0.3, 1.0));
    """
```

Notice the annotation of the argument `im` is `w_image2d_t` representing internally an image
that will be used to be written. In the case of a read-only image `r_image2d_t` must be used.

The OpenCL function `get_image_dim` can be used to retrieve the dimensions of the image.
On the other hand, the `thread_id` must be mapped to a pixel of the image, a common disposition
of pixels is to scan first the rows, so, `thread_id / dim.x` is the current row while the remainder
of the division `thread_id % dim.x` gets the column.

The `write_imagef` function in OpenCL receives the image, the pixel coordinates and a float4
with the "color". Notice that the image internally could have a different format (even a single 
component format), and this formatting is internally managed.

This `clear_image` kernel was implemented here as illustration but an efficient `clear` function
is included in `rendertoy` to clear arrays, buffers and images with a specific value pattern.

```python
ren.clear(im)  # Transparent color
ren.clear(im, 1.0)  # White
ren.clear(im, np.array([1.0, 0.0, 1.0, 1.0]))  # Magenta
```

The code here is exposed in the tutorial/lesson03_drawing_images.py script.